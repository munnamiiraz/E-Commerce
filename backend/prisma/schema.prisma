generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum productStatus {
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

model User {
  id           String         @id @default(uuid())
  name         String
  email        String         @unique
  password     String
  avatarUrl    String?
  cover        String?
  phone        String?
  address      String?
  currentRating String?
  points       Int?            @default(0)
  totalOrders  Int?            @default(0)
  totalReviews Int?            @default(0)
  designation  String?         @default("New User")

  // relations (opposites implemented in other models)
  orders       Order[]        @relation("UserOrders")
  reviews      Review[]       @relation("UserReviews")
  wishList     WishList[]
  notifications Notification[] @relation("UserNotifications")

  createdAt    DateTime       @default(now())
}

model Seller {
  id            String         @id @default(uuid())
  name          String
  email         String         @unique
  password      String
  avatarUrl     String?
  cover         String?
  phone         String?
  address       String?
  rating        String?
  totalRevenue  Int            @default(0)
  totalOrders   Int            @default(0)
  totalProducts Int            @default(0)
  totalReviews  Int            @default(0)
  designation   String         @default("New Seller")
  description   String?


  // relations
  orders        Order[]        @relation("SellerOrders")
  products      Product[]
  reviews       Review[]       @relation("SellerReviews")
  // customers     User[]         // optional semantic relation; keep if you use it
  notifications Notification[] @relation("SellerNotifications")

  createdAt     DateTime       @default(now())
}

model WishList {
  id        String  @id @default(uuid())
  user      User    @relation(fields: [userId], references: [id])
  userId    String
  product   Product @relation(fields: [productId], references: [id])
  productId String
}

model Notification {
  id        String   @id @default(uuid())
  message   String?
  createdAt DateTime @default(now())

  // make these optional so notification can belong to user OR seller (or both)
  user      User?    @relation("UserNotifications", fields: [userId], references: [id])
  userId    String?

  seller    Seller?  @relation("SellerNotifications", fields: [sellerId], references: [id])
  sellerId  String?
}

model Order {
  id          String        @id @default(uuid())

  orderedBy   User          @relation("UserOrders", fields: [orderedById], references: [id])
  orderedById String

  sendBy      Seller        @relation("SellerOrders", fields: [sendById], references: [id])
  sendById    String

  product     Product       @relation(fields: [productId], references: [id])
  productId   String

  quantity    Int
  price       Int

  status      productStatus
  createdAt   DateTime      @default(now())
  updatedAt   DateTime?
  deliveredAt DateTime?
  cancelledAt DateTime?
  shippedAt   DateTime?
  receivedAt  DateTime?

}

model Product {
  id         String    @id @default(uuid())
  name       String
  price      Int
  description String?
  rating     Float?
  images     String[]
  stock      Int
  category   String?
  createdAt  DateTime  @default(now())

  // relations / opposites
  seller     Seller    @relation(fields: [sellerId], references: [id])
  sellerId   String

  reviews    Review[]
  orders     Order[]   // opposite of Order.product
  wishLists  WishList[]
}

model Review {
  id         String   @id @default(uuid())

  product    Product  @relation(fields: [productId], references: [id])
  productId  String

  // author can be optional (e.g., guest review)
  author     User?    @relation("UserReviews", fields: [authorId], references: [id])
  authorId   String?

  // keep seller relation if you want seller-level reviews, optional
  seller     Seller?  @relation("SellerReviews", fields: [sellerId], references: [id])
  sellerId   String?

  rating     Int
  comment    String?
  createdAt  DateTime @default(now())
}
